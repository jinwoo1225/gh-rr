#!/usr/bin/env bash
set -euo pipefail

# Usage/help
if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  cat <<EOF
Usage: gh rr
Open your GitHub review-requested pull requests in a neat fzf picker.

Requires:
  - GITHUB_TOKEN environment variable
  - jq
  - fzf
  - curl

Flags:
  -h, --help    Show this help message and exit.
EOF
  exit 0
fi

: "${GITHUB_TOKEN:?Environment variable GITHUB_TOKEN must be set}"

for cmd in jq fzf curl git; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "Error: '$cmd' is required. Please install $cmd." >&2
    exit 1
  fi
done

# Load config file for custom settings if exists
RCFILE="${HOME}/.gh-rr"
if [[ -f "$RCFILE" ]]; then
  # shellcheck disable=SC1090
  source "$RCFILE"
fi
# BASE_DIR for cloning PRs; default to ~/workspace if not set
: "${BASE_DIR:=${HOME}/workspace}"

# Fetch open PRs requesting your review (exclude archived repositories)
response=$(curl -sS \
  -H "Accept: application/vnd.github.v3+json" \
  -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/search/issues?q=is:pr+is:open+review-requested:@me+archived:false&per_page=100")

# Extract repo, title, age, URL; sort oldest-first and format age
entries=$(jq -r '
  .items
  | map({
      repo: (.repository_url | sub("https://api.github.com/repos/"; "")),
      title: .title,
      url: .html_url,
      age: (now - (.created_at | fromdateiso8601))
    })
  | sort_by(.age) | reverse
  | .[]
  | (
      def human($s):
        if    $s <   60   then "\($s|floor)s"
        elif  $s < 3600   then "\(($s/60)|floor)m"
        elif  $s < 86400  then "\(($s/3600)|floor)h"
        elif  $s < 604800 then "\(($s/86400)|floor)d"
        else                   "\(($s/604800)|floor)w" end;
      "\(.repo)\t\(.title)\t\(human(.age))\t\(.url)"
    )
' <<<"$response")

# If no review-requested PRs, inform the user and continue (use 'm' to view your PRs)
if [[ -z "$entries" ]]; then
  echo "No review-requested PRs found; press 'm' to view your PRs." >&2
fi

# Pad columns for neat display (repo, title, age)
entries=$(printf "%s\n" "$entries" \
  | awk -F $'\t' '{ lines[NR]=$0; if (NR==1||length($1)>w1) w1=length($1); if (NR==1||length($2)>w2) w2=length($2); if (NR==1||length($3)>w3) w3=length($3) } \
      END { for(i=1;i<=NR;i++){ split(lines[i],f,FS); printf "%-*s\t%-*s\t%-*s\t%s\n", w1,f[1],w2,f[2],w3,f[3],f[4] } }')

# Fetch PRs authored by you
response_my=$(curl -sS \
  -H "Accept: application/vnd.github.v3+json" \
  -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/search/issues?q=is:pr+is:open+author:@me+archived:false&per_page=100")
entries_my=$(jq -r '
  .items
  | map({
      repo: (.repository_url | sub("https://api.github.com/repos/"; "")),
      title: .title,
      url: .html_url,
      age: (now - (.created_at | fromdateiso8601))
    })
  | sort_by(.age) | reverse
  | .[]
  | (
      def human($s):
        if    $s <   60   then "\($s|floor)s"
        elif  $s < 3600   then "\(($s/60)|floor)m"
        elif  $s < 86400  then "\(($s/3600)|floor)h"
        elif  $s < 604800 then "\(($s/86400)|floor)d"
        else                   "\(($s/604800)|floor)w" end;
      "\(.repo)\t\(.title)\t\(human(.age))\t\(.url)"
    )' <<<"$response_my")

# Write entries to temp files for fzf reload
tmp_rev=$(mktemp)
tmp_my=$(mktemp)
printf "%s\n" "$entries" > "$tmp_rev"
printf "%s\n" "$entries_my" > "$tmp_my"

# Picker with reload: review or my PRs; expect enter,c keys
# Fallback for bash<4: read fzf output into array
lines=()
while IFS= read -r line; do
  lines+=("$line")
done < <(fzf --header='Select PR: Enter=Open, c=Clone & checkout; m=My PRs, r=Review requests' \
  --delimiter=$'\t' \
  --with-nth=1,2,3 \
  --ansi \
  --expect=enter,c \
  --bind "m:reload(cat $tmp_my)" \
  --bind "r:reload(cat $tmp_rev)" \
  < "$tmp_rev")

# Cleanup temp files
rm -f "$tmp_rev" "$tmp_my"
# No selection? exit
if [ "${#lines[@]}" -lt 2 ]; then
  exit 0
fi
key="${lines[0]}"
selected="${lines[1]}"

repo=$(echo "$selected" | cut -f1)
url=$(echo "$selected" | cut -f4)

if [ "$key" = "c" ]; then
  pr_number="${url##*/}"
  clone_dir="${BASE_DIR}/${repo}"
  printf "Clone directory: %s\n" "$clone_dir"
  read -rp "Clone into this directory? [y/N] " yn
  if [[ ! "$yn" =~ ^[Yy] ]]; then
    exit 0
  fi
  if [[ ! -d "$clone_dir/.git" ]]; then
    mkdir -p "$(dirname "$clone_dir")"
    git clone "https://github.com/${repo}.git" "$clone_dir"
  fi
  cd "$clone_dir"
  # Checkout using GH CLI if available, otherwise manual fetch & checkout
  if command -v gh >/dev/null 2>&1; then
    gh pr checkout "$pr_number"
  else
    # Fallback without GH CLI: fetch PR metadata and checkout actual head branch
    pr_json=$(curl -sS \
      -H "Accept: application/vnd.github.v3+json" \
      -H "Authorization: token $GITHUB_TOKEN" \
      "https://api.github.com/repos/${repo}/pulls/${pr_number}")
    head_ref=$(jq -r .head.ref <<<"$pr_json")
    head_repo_full=$(jq -r .head.repo.full_name <<<"$pr_json")
    head_repo_url=$(jq -r .head.repo.clone_url <<<"$pr_json")
    if [[ "$head_repo_full" == "$repo" ]]; then
      git fetch origin pull/${pr_number}/head
      git checkout -b "$head_ref" FETCH_HEAD
    else
      remote_name="pr-${pr_number}"
      git remote add "$remote_name" "$head_repo_url" 2>/dev/null || true
      git fetch "$remote_name" "$head_ref"
      git checkout -b "$head_ref" --track "$remote_name/$head_ref"
    fi
  fi
  echo "Checked out PR #${pr_number} in $clone_dir"
  exec "$SHELL"
else
  # Open URL (4th field)
  if command -v xdg-open &>/dev/null; then
    xdg-open "$url"
  elif command -v open &>/dev/null; then
    open "$url"
  else
    echo "Please open this URL manually: $url"
  fi
fi